package;

import hxp.*;
import lime.tools.*;
import sys.FileSystem;

using StringTools;

/**
 * This HXP performs the functions of a Lime `Project.xml` file,
 * but it's written in Haxe rather than XML!
 *
 * This makes it far easier to organize, reuse, and refactor,
 * and improves management of feature flag logic.
 */
@:nullSafety
class Project extends HXProject
{
  //
  // METADATA
  // ===========================

  /**
   * The game's version number, as a Semantic Versioning string with no prefix.
   * REMEMBER TO CHANGE THIS WHEN THE GAME UPDATES!
   * You only have to change it here, the rest of the game will query this value.
   */
  static final VERSION:String = '0.1.0-demo';

  /**
   * The game's name. Used as the default window title.
   */
  static final TITLE:String = 'Friday Night Funkin\'';

  /**
   * The name of the generated executable file.
   * For example, `"Funkin"` will create a file called `Funkin.exe`.
   */
  static final EXECUTABLE_NAME:String = 'PolyverseEngine';

  /**
   * The relative location of the source code.
   */
  static final SOURCE_DIR:String = 'source';

  /**
   * The fully qualified class path for the game's preloader.
   * Particularly important on HTML5 but it's used on all platforms.
   */
  static final PRELOADER:String = 'flixel.system.FlxPreloader';

  /**
   * A package name used for identifying the app on various app stores.
   */
  static final PACKAGE_NAME:String = 'net.stringfromjava.polyverseengine';

  /**
   * The fully qualified class path for the entry point class to execute when launching the game.
   * It's where `public static function main():Void` goes.
   */
  static final MAIN_CLASS:String = 'Main';

  /**
   * The company name for the game.
   * This appears as metadata in many places.
   */
  static final COMPANY:String = 'Polyverse Dev Team';

  /**
   * Path to the Haxe script run before building the game.
   */
  // static final PREBUILD_HX:String = 'source/Prebuild.hx';
  /**
   * Path to the Haxe script run after building the game.
   */
  // static final POSTBUILD_HX:String = 'source/Postbuild.hx';

  /**
   * Asset path globs to always exclude from asset libraries.
   */
  static final EXCLUDE_ASSETS:Array<String> = ['.*', 'cvs', 'thumbs.db', 'desktop.ini', '*.hash', '*.md'];

  /**
   * Asset path globs to exclude on web platforms.
   */
  static final EXCLUDE_ASSETS_WEB:Array<String> = ['*.ogg'];

  /**
   * Asset path globs to exclude on native platforms.
   */
  static final EXCLUDE_ASSETS_NATIVE:Array<String> = ['*.mp3'];

  //
  // FEATURE FLAGS
  // ==========================================

  /**
   * Are mods allowed to be registered and loaded in the game?
   */
  static final MODS_ALLOWED:FeatureFlag = 'MODS_ALLOWED';

  /**
   * Is the user allowed to earn awards in-game?
   */
  static final ACHIEVEMENTS_ALLOWED:FeatureFlag = 'ACHIEVEMENTS_ALLOWED';

  /**
   * Should the game display in the user's Discord "Activity" box?
   */
  static final DISCORD_ALLOWED:FeatureFlag = 'DISCORD_ALLOWED';

  /**
   * Are other language translations allowed to be loaded?
   */
  static final TRANSLATIONS_ALLOWED:FeatureFlag = 'TRANSLATIONS_ALLOWED';

  /**
   * Is multithreading allowed for loading transitions?
   */
  static final MULTITHREADED_LOADING:FeatureFlag = 'MULTITHREADED_LOADING';

  /**
   * Should there be a loading screen visible instead of just a black screen?
   */
  static final SHOW_LOADING_SCREEN:FeatureFlag = 'SHOW_LOADING_SCREEN';

  /**
   * Should the game's base files be included into the build?
   */
  static final BASE_GAME_FILES:FeatureFlag = 'BASE_GAME_FILES';

  /**
   * Are videos allowed to be played in-game?
   */
  static final VIDEOS_ALLOWED:FeatureFlag = 'VIDEOS_ALLOWED';

  /**
   * Should the game use its built-in crash handler when the game has an exception?
   */
  static final CRASH_HANDLER:FeatureFlag = 'CRASH_HANDLER';

  /**
   * Should the game make an HTTP request to check for updates?
   */
  static final CHECK_FOR_UPDATES:FeatureFlag = 'CHECK_FOR_UPDATES';

  public function new()
  {
    super();

    flair();
    configureApp();

    displayTarget();
    configureOutputDir();
    configureFeatureFlags();
    configureCompileDefines();
    configureHaxelibs();
    configureAssets();
    configureIcons(); // TODO: Implement code when icons are made!
  }

  /**
   * Display some fancy info before initializing.
   */
  function flair()
  {
    info('FNF: POLYVERSE ENGINE');
    info('Setting up build...');
    info('Target Version: ' + VERSION);
    info('Git Branch:     ' + getGitBranch());
    info('Git Commit:     ' + getGitCommit());
    info('Git Modified?   ' + getGitModified());
    info('Display?        ' + isDisplay());
    logSeparator();
  }

  /**
   * Apply basic project metadata, such as the game title and version number,
   * as well as info like the package name and company (used by various app stores).
   */
  function configureApp()
  {
    //
    // METADATA
    // ======================================
    this.meta.title = TITLE;
    this.meta.version = VERSION;
    this.meta.packageName = PACKAGE_NAME;
    this.meta.company = COMPANY;
    this.meta.description = 'A heavily modified and simplified version of FNF: Psych Engine.';
    this.meta.companyId = COMPANY;
    this.meta.companyUrl = COMPANY;

    //
    // CODE
    // =================================
    this.sources.push(SOURCE_DIR);  // Source code location (more than one can be added).

    //
    // PREBUILD & POSTBUILD
    // ==================================================
    // this.preBuildCallbacks.push(buildHaxeCLICommand(PREBUILD_HX));
    // this.postBuildCallbacks.push(buildHaxeCLICommand(POSTBUILD_HX));

    //
    // APP
    // ==========================
    this.app.main = MAIN_CLASS;
    this.app.preloader = PRELOADER;
    this.app.file = EXECUTABLE_NAME;
    // These values are only used by the SWF target
    // this.app.path
    // this.app.init
    // this.app.swfVersion
    // this.app.url

    //
    // WINDOW
    // =====================================
    this.window.fps = 60;
    this.window.width = (!isMobile()) ? 1280 : 0;
    this.window.height = (!isMobile()) ? 720 : 0;
    this.window.background = 0xFF000000;
    this.window.fullscreen = false;
    this.window.resizable = true;
    this.window.orientation = (isDesktop() || isMobile()) ? Orientation.LANDSCAPE : Orientation.AUTO;
    this.window.hardware = true;
    this.window.vsync = false;
    this.window.allowHighDPI = true; // Force / allow high DPI
  }

  /**
   * Log information about the configured target platform.
   */
  function displayTarget()
  {
    // Display the target operating system.
    switch (this.target)
    {
      case Platform.WINDOWS:
        info('Target Platform: Windows');
      case Platform.MAC:
        info('Target Platform: MacOS');
      case Platform.LINUX:
        info('Target Platform: Linux');
      case Platform.ANDROID:
        info('Target Platform: Android');
      case Platform.IOS:
        info('Target Platform: IOS');
      case Platform.HTML5:
        info('Target Platform: HTML5');
      // See lime.tools.Platform for a full list.
      // ==============================================
      // case Platform.EMSCRITEN:
      // case Platform.AIR:
      // case Platform.BLACKBERRY:
      // case Platform.CONSOLE_PC:
      // case Platform.FIREFOX:
      // case Platform.FLASH:
      // case Platform.PS3:
      // case Platform.PS4:
      // case Platform.TIZEN:
      // case Platform.TVOS:
      // case Platform.VITA:
      // case Platform.WEBOS:
      // case Platform.WIIU:
      // case Platform.XBOX1:
      default:
        error('Unsupported platform (got ${target})');
    }

    switch (this.platformType)
    {
      case PlatformType.DESKTOP:
        info('Target Platform Type: Desktop');
      case PlatformType.MOBILE:
        info('Target Platform Type: Mobile');
      case PlatformType.WEB:
        info('Target Platform Type: Web');
      case PlatformType.CONSOLE:
        info('Target Platform Type: Console');
      default:
        error('Unknown target platform type (got ${platformType})');
    }

    // Print whether we are using HXCPP, HashLink, or something else.
    if (isWeb())
    {
      info('Target Language: JavaScript (HTML5)');
    }
    else if (isHashLink())
    {
      info('Target Language: HashLink');
    }
    else if (isNeko())
    {
      info('Target Language: Neko');
    }
    else if (isJava())
    {
      info('Target Language: Java');
    }
    else if (isNodeJS())
    {
      info('Target Language: JavaScript (NodeJS)');
    }
    else if (isCSharp())
    {
      info('Target Language: C#');
    }
    else if (isCPlusPlus())
    {
      info('Target Language: C++');
    }
    else
    {
      info('Target Language: Unknown');
    }

    for (arch in this.architectures)
    {
      // Display the list of target architectures.
      switch (arch)
      {
        case Architecture.X86:
          info('Architecture: x86');
        case Architecture.X64:
          info('Architecture: x64');
        case Architecture.ARMV5:
          info('Architecture: ARMv5');
        case Architecture.ARMV6:
          info('Architecture: ARMv6');
        case Architecture.ARMV7:
          info('Architecture: ARMv7');
        case Architecture.ARMV7S:
          info('Architecture: ARMv7S');
        case Architecture.ARM64:
          info('Architecture: ARMx64');
        case Architecture.MIPS:
          info('Architecture: MIPS');
        case Architecture.MIPSEL:
          info('Architecture: MIPSEL');
        case null:
          if (!isWeb())
          {
            error('Unsupported architecture (got null on non-web platform)');
          }
          else
          {
            info('Architecture: Web');
          }
        default:
          error('Unsupported architecture (got ${arch})');
      }
    }
  }

  /**
   * Apply various feature flags based on the target platform and the user-provided build flags.
   */
  function configureFeatureFlags()
  {
    info('Configuring feature flags...');

    // Enable mods and the scripting system for desktop platforms only.
    MODS_ALLOWED.apply(this, isDesktop());

    // Cool awards you can earn by completing certain tasks in-game.
    ACHIEVEMENTS_ALLOWED.apply(this, true);

    // Enable Discord rich presence by default.
    DISCORD_ALLOWED.apply(this, true);

    // Enable translations by default.
    TRANSLATIONS_ALLOWED.apply(this, true);

    // Enable base game files by default.
    // If you're making a mod by modifying the engine's source code,
    // we recommend setting this conditional to false!
    BASE_GAME_FILES.apply(this, true);

    // Official build conditionals only.
    if (isOfficialBuild())
    {
      VIDEOS_ALLOWED.apply(this, isWindows() || isMac() || isLinux() || isAndroid() && !is32Bit());
    }

    // Enable the crash handler on released desktop builds.
    CRASH_HANDLER.apply(this, isDesktop() && isRelease());

    // Make an HTTP request to check for updates on official builds.
    CHECK_FOR_UPDATES.apply(this, isDesktop() && isOfficialBuild());

    logSeparator();
  }

  /**
   * Set compilation flags which are not feature flags.
   */
  function configureCompileDefines()
  {
    // Enable OpenFL's error handler.
    // Required for the crash handler.
    setHaxedef('openfl-enable-handle-error');

    // Enable stack trace tracking for the crash handler.
    // Good for debugging but has a (minor) performance impact.
    if (CRASH_HANDLER.isEnabled(this))
    {
      setHaxedef('HXCPP_CHECK_POINTER');
      setHaxedef('HXCPP_STACK_LINE');
      setHaxedef('HXCPP_STACK_TRACE');
    }

    setHaxedef('safeMode');

    // Disable the built in pause screen when unfocusing the game.
    setHaxedef('FLX_NO_FOCUS_LOST_SCREEN');

    // Disable the Flixel debugger entirely.
    setHaxedef('FLX_NO_DEBUG');

    if (isRelease())
    {
      // Improve performance on Nape.
      setHaxedef('NAPE_RELEASE_BUILD');
    }

    // Disable the Discord IO thread.
    if (DISCORD_ALLOWED.isEnabled(this))
    {
      setHaxedef('DISCORD_DISABLE_IO_THREAD');
    }

    if (isLinux())
    {
      setHaxedef('NO_PRECOMPILED_HEADERS');
    }

    if (VIDEOS_ALLOWED.isEnabled(this) && isDebug())
    {
      setHaxedef('HXC_LIBVLC_LOGGING');
    }

    if (VIDEOS_ALLOWED.isEnabled(this))
    {
      setHaxedef('HXVLC_NO_SHARE_DIRECTORY');
    }

    // Cleaner looking compiler errors.
    setHaxedef('message.reporting', 'pretty');

    // Since we most likely won't update the engine to a newer
    // version of Haxe, we just disable deprecation warnings to get them out the way.
    setHaxedef('no-deprecation-warnings');

    // Mark official builds. This makes the `officialBuild` compile-time
    // define available to Haxe sources (use `#if officialBuild`). We enable
    // it automatically for release builds, but also allow overriding via
    // an explicit CLI define: `-DofficialBuild`.
    if (isOfficialBuild())
    {
      setHaxedef('officialBuild');
    }
    else
    {
      // Ensure it isn't accidentally left set for non-official builds.
      unsetHaxedef('officialBuild');
    }

    addHaxeMacro('allowPackage(\'flash\')');
    addHaxeMacro('include(\'my.pack\')');
  }

  function configureOutputDir()
  {
    // Set the output directory.
    // Depends on the target platform, architecture and build type.
    var buildDir = 'export/${isDebug() ? 'debug' : isRelease() ? 'release' : 'test'}';
    buildDir += isWeb() ? '/web' : isMobile() ? '/mobile' : isDesktop() ? '/desktop' : isConsole() ? '/console' : '/unknown';
    if (is32Bit())
    {
      buildDir += '/x86';
    }
    else if (is64Bit())
    {
      buildDir += '/x64';
    }
    buildDir += '/';
    info('Output Directory: $buildDir');
    app.path = buildDir;
    logSeparator();
  }

  function configureHaxelibs()
  {
    //
    // FLIXEL
    // ==================

    // Convert the game to run on other platforms.
    addHaxelib('lime', '8.1.2');
    // Many frontend and backend utilities for the game's display.
    addHaxelib('openfl', '9.3.3');
    // Core game library.
    addHaxelib('flixel', '5.6.1');
    // Additional utilities for Flixel.
    addHaxelib('flixel-addons', '3.2.2');
    // Helpful tools for working with Flixel.
    addHaxelib('flixel-tools', '1.5.1');
    
    //
    // CUSTOM
    // ===================

    // Audio visualizer.
    addHaxelib('grig.audio');
    // JSON parsing.
    addHaxelib('tjson', '1.4.0');
    // Discord rich presence.
    if (DISCORD_ALLOWED.isEnabled(this))
    {
      addHaxelib('hxdiscord_rpc', '1.2.4');
    }
    // Display video files in-game.
    addHaxelib('hxvlc', '2.0.1');
    // Adobe animate support.
    addHaxelib('flxanimate');
    // Audio data into frequency data.
    if (BASE_GAME_FILES.isEnabled(this))
    {
      addHaxelib('funkin.vis');
    }
  }

  function configureAssets()
  {
    final includedSounds = [!isWeb() ? '*.ogg' : '*.mp3'];
    final embed = isWeb();
    final excludedExtras = EXCLUDE_ASSETS;
    excludedExtras.push(isWeb() ? '*.ogg' : '*.mp3');

    addAssetPath('assets/fonts', null, 'default', ['*.ttf'], EXCLUDE_ASSETS);
    addAssetPath('assets/shared', null, 'default', ['*.png', '*.xml', '*.json', '*.txt'], EXCLUDE_ASSETS);
    addAssetPath('assets/embed', null, 'default', includedSounds, EXCLUDE_ASSETS, embed);
    if (VIDEOS_ALLOWED.isEnabled(this))
    {
      addAssetPath('assets/videos', null, 'default', ['*.mp4'], EXCLUDE_ASSETS);
    }
    addAssetPath('assets/songs', null, 'default', includedSounds, EXCLUDE_ASSETS);

    if (BASE_GAME_FILES.isEnabled(this))
    {
      addAssetPath('assets/base_game', 'assets', 'default', ['*.png', '*.xml', '*.json', '*.mp3', '*.ogg'], excludedExtras);
    }

    if (MODS_ALLOWED.isEnabled(this))
    {
      addAssetPath('example_mods', 'mods', 'default', ['*.zip'], EXCLUDE_ASSETS);
      addAsset('list.txt', 'modsList.txt', 'default');
    }

    addAsset('art/readme.txt', 'do NOT readme.txt', 'default');

    if (isDesktop())
    {
      if (isWindows())
      {
        addAsset('alsoft.txt', 'plugins/alsoft.ini', 'default');
      }
      else
      {
        addAsset('alsoft.txt', 'plugins/alsoft.conf', 'default');
      }
    }

    if (isMac() || isLinux())
    {
      addAsset('art/icons/iconOG.png', 'icon.png', 'default');
    }

    logSeparator();
  }

  /**
   * Configure the application's favicon and executable icon.
   */
  function configureIcons()
  {
    addIcon('art/icons/icon16.png', 16);
    addIcon('art/icons/icon32.png', 32);
    addIcon('art/icons/icon64.png', 64);
    addIcon('art/icons/iconOG.png');
  }

  //
  // HELPER FUNCTIONS
  // (Easy functions to make the code more readable.)
  // ========================================================================

  public function isWeb():Bool
  {
    return this.platformType == PlatformType.WEB;
  }

  public function isMobile():Bool
  {
    return this.platformType == PlatformType.MOBILE;
  }

  public function isDesktop():Bool
  {
    return this.platformType == PlatformType.DESKTOP;
  }

  public function isConsole():Bool
  {
    return this.platformType == PlatformType.CONSOLE;
  }

  public function is32Bit():Bool
  {
    return this.architectures.contains(Architecture.X86);
  }

  public function is64Bit():Bool
  {
    return this.architectures.contains(Architecture.X64);
  }

  public function isWindows():Bool
  {
    return this.target == Platform.WINDOWS;
  }

  public function isMac():Bool
  {
    return this.target == Platform.MAC;
  }

  public function isLinux():Bool
  {
    return this.target == Platform.LINUX;
  }

  public function isAndroid():Bool
  {
    return this.target == Platform.ANDROID;
  }

  public function isIOS():Bool
  {
    return this.target == Platform.IOS;
  }

  public function isHashLink():Bool
  {
    return this.targetFlags.exists('hl');
  }

  public function isNeko():Bool
  {
    return this.targetFlags.exists('neko');
  }

  public function isJava():Bool
  {
    return this.targetFlags.exists('java');
  }

  public function isNodeJS():Bool
  {
    return this.targetFlags.exists('nodejs');
  }

  public function isCSharp():Bool
  {
    return this.targetFlags.exists('cs');
  }

  public function isCPlusPlus():Bool
  {
    return this.defines.exists('cpp'); // Why in defines and not target flags...
  }

  public function isOfficialBuild():Bool
  {
    return isRelease() || hasDefine('officialBuild');
  }

  public function isDisplay():Bool
  {
    return this.command == 'display';
  }

  public function isDebug():Bool
  {
    return this.debug;
  }

  public function isRelease():Bool
  {
    return this.defines.exists('final');
  }

  public function getHaxedef(name:String):Null<Dynamic>
  {
    return this.haxedefs.get(name);
  }

  public function setHaxedef(name:String, ?value:String):Void
  {
    if (value == null)
      value = '';

    this.haxedefs.set(name, value);
  }

  public function unsetHaxedef(name:String):Void
  {
    this.haxedefs.remove(name);
  }

  public function getDefine(name:String):Null<Dynamic>
  {
    return this.defines.get(name);
  }

  public function hasDefine(name:String):Bool
  {
    return this.defines.exists(name);
  }

  /**
   * Add a library to the list of dependencies for the project.
   * 
   * @param name The name of the library to add.
   * @param version The version of the library to add. Optional.
   */
  public function addHaxelib(name:String, version:String = ''):Void
  {
    this.haxelibs.push(new Haxelib(name, version));
  }

  /**
   * Add a `haxeflag` to the project.
   */
  public function addHaxeFlag(value:String):Void
  {
    this.haxeflags.push(value);
  }

  /**
   * Call a Haxe build macro.
   */
  public function addHaxeMacro(value:String):Void
  {
    addHaxeFlag('--macro ${value}');
  }

  /**
   * Add an icon to the project.
   * 
   * @param icon The path to the icon.
   * @param size The size of the icon. Optional.
   */
  public function addIcon(icon:String, ?size:Int):Void
  {
    this.icons.push(new Icon(icon, size));
  }

  /**
   * Add an asset to the game build.
   * 
   * @param path    The path the asset is located at.
   * @param rename  The path the asset should be placed.
   * @param library The asset library to add the asset to. `null` = 'default'
   * @param embed   Whether to embed the asset in the executable.
   */
  public function addAsset(path:String, ?rename:String, ?library:String, embed:Bool = false):Void
  {
    // path, rename, type, embed, setDefaults
    var asset = new Asset(path, rename, null, embed, true);
    @:nullSafety(Off)
    {
      asset.library = library ?? 'default';
    }
    this.assets.push(asset);
  }

  /**
   * Add an entire path of assets to the game build.
   * 
   * @param path    The path the assets are located at.
   * @param rename  The path the assets should be placed.
   * @param library The asset library to add the assets to. `null` = 'default'
   * @param include An optional array to include specific asset names.
   * @param exclude An optional array to exclude specific asset names.
   * @param embed   Whether to embed the assets in the executable.
   */
  public function addAssetPath(path:String, ?rename:String, library:String, ?include:Array<String>, ?exclude:Array<String>, embed:Bool = false):Void
  {
    // Argument parsing.
    if (path == '')
      return;

    if (include == null)
      include = [];

    if (exclude == null)
      exclude = [];

    var targetPath = rename ?? path;
    if (targetPath != '')
      targetPath += '/';

    // Validate path
    if (!sys.FileSystem.exists(path))
    {
      error('Could not find asset path "${path}".');
    }
    else if (!sys.FileSystem.isDirectory(path))
    {
      error('Could not parse asset path "${path}", expected a directory.');
    }
    else
    {
      info('Adding asset path ${path}...');
    }

    for (file in sys.FileSystem.readDirectory(path))
    {
      if (sys.FileSystem.isDirectory('${path}/${file}'))
      {
        // Attempt to recursively add all assets in the directory
        if (this.filter(file, ['*'], exclude))
        {
          addAssetPath('${path}/${file}', '${targetPath}${file}', library, include, exclude, embed);
        }
      }
      else
      {
        if (this.filter(file, include, exclude))
        {
          addAsset('${path}/${file}', '${targetPath}${file}', library, embed);
        }
      }
    }
  }

  /**
   * Add an asset library to the game build.
   * 
   * @param name The name of the library.
   * @param embed
   * @param preload
   */
  public function addAssetLibrary(name:String, embed:Bool = false, preload:Bool = false):Void
  {
    // sourcePath, name, type, embed, preload, generate, prefix
    var sourcePath = '';
    this.libraries.push(new Library(sourcePath, name, null, embed, preload, false, ''));
  }

  //
  // PROCESS FUNCTIONS
  //

  /**
   * A CLI command to run a command in the shell.
   */
  public function buildCLICommand(cmd:String):CLICommand
  {
    return CommandHelper.fromSingleString(cmd);
  }

  /**
   * A CLI command to run a Haxe script via `--interp`.
   */
  public function buildHaxeCLICommand(path:String):CLICommand
  {
    return CommandHelper.interpretHaxe(path);
  }

  public function getGitCommit():String
  {
    // Cannibalized from GitCommit.hx
    var process = new sys.io.Process('git', ['rev-parse', 'HEAD']);
    if (process.exitCode() != 0)
    {
      var message = process.stderr.readAll().toString();
      error('[ERROR] Could not determine current git commit; is this a proper Git repository?');
    }

    var commitHash:String = process.stdout.readLine();
    var commitHashSplice:String = commitHash.substr(0, 7);

    process.close();

    return commitHashSplice;
  }

  public function getGitBranch():String
  {
    // Cannibalized from GitCommit.hx
    var branchProcess = new sys.io.Process('git', ['rev-parse', '--abbrev-ref', 'HEAD']);

    if (branchProcess.exitCode() != 0)
    {
      var message = branchProcess.stderr.readAll().toString();
      error('Could not determine current git branch; is this a proper Git repository?');
    }

    var branchName:String = branchProcess.stdout.readLine();

    branchProcess.close();

    return branchName;
  }

  public function getGitModified():Bool
  {
    var branchProcess = new sys.io.Process('git', ['status', '--porcelain']);

    if (branchProcess.exitCode() != 0)
    {
      var message = branchProcess.stderr.readAll().toString();
      error('Could not determine current git status; is this a proper Git repository?');
    }

    var output:String = '';
    try
    {
      output = branchProcess.stdout.readLine();
    }
    catch (e)
    {
      if (e.message == 'Eof')
      {
        // Do nothing
        // Eof = No output
      }
      else
      {
        // Rethrow other exceptions
        throw e;
      }
    }

    branchProcess.close();

    return output.length > 0;
  }

  //
  // LOGGING FUNCTIONS
  // ==============================

  /**
   * Display an info message. This should not interfere with the build process.
   */
  public function info(message:String):Void
  {
    if (command != 'display')
    {
      Log.info('[INFO] ${message}');
    }
  }

  /**
   * Display an error message. This should stop the build process.
   */
  public function error(message:String):Void
  {
    Log.error('${message}');
  }

  /**
   * Display a very long line to separate sections of the game's
   * setup, mainly for easy readability.
   */
  public function logSeparator():Void
  {
    info('-------------------------------------------------------------');
  }
}

/**
 * An object representing a feature flag, which can be enabled or disabled.
 * Includes features such as automatic generation of compile defines and inversion.
 */
abstract FeatureFlag(String)
{
  static final INVERSE_PREFIX:String = 'NO_';

  public function new(input:String)
  {
    this = input;
  }

  @:from
  public static function fromString(input:String):FeatureFlag
  {
    return new FeatureFlag(input);
  }

  /**
   * Enable/disable a feature flag if it is unset, and handle the inverse flag.
   * Doesn't override a feature flag that was set explicitly.
   * @param enableByDefault Whether to enable this feature flag if it is unset.
   */
  public function apply(project:Project, enableByDefault:Bool = false):Void
  {
    // TODO: Name this function better?

    if (isEnabled(project))
    {
      // If this flag was already enabled, disable the inverse
      project.info('Enabling feature flag ${this}');
      getInverse().disable(project, false);
    }
    else if (getInverse().isEnabled(project))
    {
      // If the inverse flag was already enabled, disable this flag
      project.info('Disabling feature flag ${this}');
      disable(project, false);
    }
    else
    {
      if (enableByDefault)
      {
        // Enable this flag if it was unset, and disable the inverse
        project.info('Enabling feature flag ${this}');
        enable(project, true);
      }
      else
      {
        // Disable this flag if it was unset, and enable the inverse
        project.info('Disabling feature flag ${this}');
        disable(project, true);
      }
    }
  }

  /**
   * Enable this feature flag by setting the appropriate compile define.
   *
   * @param project The project to modify.
   * @param andInverse Also disable the feature flag's inverse.
   */
  public function enable(project:Project, andInverse:Bool = true)
  {
    project.setHaxedef(this, '');
    if (andInverse)
    {
      getInverse().disable(project, false);
    }
  }

  /**
   * Disable this feature flag by removing the appropriate compile define.
   *
   * @param project The project to modify.
   * @param andInverse Also enable the feature flag's inverse.
   */
  public function disable(project:Project, andInverse:Bool = true)
  {
    project.unsetHaxedef(this);
    if (andInverse)
    {
      getInverse().enable(project, false);
    }
  }

  /**
   * Query if this feature flag is enabled.
   * @param project The project to query.
   */
  public function isEnabled(project:Project):Bool
  {
    // Check both Haxedefs and Defines for this flag
    return project.haxedefs.exists(this) || project.defines.exists(this);
  }

  /**
   * Query if this feature flag's inverse is enabled.
   */
  public function isDisabled(project:Project):Bool
  {
    return getInverse().isEnabled(project);
  }

  /**
   * Return the inverse of this feature flag.
   * @return A new feature flag that is the inverse of this one.
   */
  public function getInverse():FeatureFlag
  {
    if (this.startsWith(INVERSE_PREFIX))
    {
      return this.substring(INVERSE_PREFIX.length);
    }
    return INVERSE_PREFIX + this;
  }
}
